<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <title>A Technical Documentation Page</title> 
  
  <link rel="stylesheet" href="css/style.css">
  
</head>

<body>

      <link href="https://fonts.googleapis.com/css?family=Amatic SC" rel="stylesheet" type="text/css">
  
<nav id="navbar">
  <header id="main_header">Sorting Algorithms using Java!</header>
  <ul> 
    <a class="nav-link" href="#Introduction" rel="internal"><li>What is a sorting algorithm?</li></a>
	<a class="nav-link" href="#BubbleSort" rel="internal"><li>Bubble Sort</li></a>
	<a class="nav-link" href="#InsertionSort" rel="internal"><li>Insertion Sort</li></a>
	<a class="nav-link" href="#MergeSort" rel="internal"><li>Merge Sort</li></a>
	<a class="nav-link" href="#QuickSort" rel="internal"><li>Quick Sort</li></a>
	<a class="nav-link" href="#SelectionSort" rel="internal"><li>Selection Sort</li></a>
    <a class="nav-link" href="#Reference" rel="internal"><li>References</li></a>
	
  </ul>
</nav>

<main id="main-doc">

  <section class="main-section" id="Introduction">
    <header>What is a sorting algorithm?</header>
    <article> 
        <p>A sorting algorithm can be defined as an algorithm that puts elements of a list in a certain order.
        Such algorithms are important for optimizing the use of other algorithms such as search and merge algorithms which can be use for complex database systems.
        The main sorting algorithms consist of quick sort, insertion sort, selection sort, bubble sort and merge sort. These algorithms are are consider to be known as Big O "O(n) and O(n^2)" algorithms.</p>	
    </article>
  </section>
  
  <section class="main-section" id="BubbleSort">
    <header>Bubble Sort</header>
    <article>
	   <p>This algorithm compares each item in the list with the item next to it, and swapping them if required. That is, the largest element has bubbled to the top of the list. The algorithm repeats this process until it makes a pass all the way through the list without swapping any items.</p>
	   <p>Code example:</p>
		<code>  
public class BubbleSort 
{
  
    // logic to sort the elements
    public static void bubble_srt(int array[]) {
        int n = array.length;
        int k;
        for (int m = n; m >= 0; m--) {
            for (int i = 0; i < n - 1; i++) {
                k = i + 1;
                if (array[i] > array[k]) {
                    swapNumbers(i, k, array);
                }
            }
            printNumbers(array);
        }
    }
  
    private static void swapNumbers(int i, int j, int[] array) {
  
        int temp;
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
  
    private static void printNumbers(int[] input) {
          
        for (int i = 0; i < input.length; i++) {
            System.out.print(input[i] + ", ");
        }
        System.out.println("\n");
    }
  
    public static void main(String[] args) {
        int[] input = { 4, 2, 9, 6, 23, 12, 34, 0, 1 };
        bubble_srt(input);
  
    }
}
		</code>
    </article>
  </section>
   
  
  <section class="main-section" id="InsertionSort">
    <header>Insertion Sort</header>
    <article>
	   <p>This algorithm sort's an unordered list of elements and removes its entries one at a time and then insert each of them into a sorted part which initially was empty.</p>
	   <p>Code example:</p>
		<code>
public class InsertionSort 
{
 
    public static void main(String a[]){
        int[] arr1 = {10,34,2,56,7,67,88,42};
        int[] arr2 = doInsertionSort(arr1);
        for(int i:arr2){
            System.out.print(i);
            System.out.print(", ");
        }
    }
     
    public static int[] doInsertionSort(int[] input){
         
        int temp;
        for (int i = 1; i < input.length; i++) {
            for(int j = i ; j > 0 ; j--){
                if(input[j] < input[j-1]){
                    temp = input[j];
                    input[j] = input[j-1];
                    input[j-1] = temp;
                }
            }
        }
        return input;
    }
}
		</code>
    </article>
  </section>
  
  <section class="main-section" id="MergeSort">
    <header>Merge Sort</header>
    <article>
	   <p>Based on the divide-and-conquer paradigm. It involves the following three steps:</p> 
        <li>Divide the array into two (or more) sub-arrays</li>
        <li>Sort each subarray (Conquer)</li>
        <li>Merge them into one (in a smart way!)</li> 
	   <p>Code example:</p>
		<code>
public class MergeSort 
{
     
    private int[] array;
    private int[] tempMergArr;
    private int length;
 
    public static void main(String a[]){
         
        int[] inputArr = {45,23,11,89,77,98,4,28,65,43};
        MergeSort mms = new MyMergeSort();
        mms.sort(inputArr);
        for(int i:inputArr){
            System.out.print(i);
            System.out.print(" ");
        }
    }
     
    public void sort(int inputArr[]) {
        this.array = inputArr;
        this.length = inputArr.length;
        this.tempMergArr = new int[length];
        doMergeSort(0, length - 1);
    }
 
    private void doMergeSort(int lowerIndex, int higherIndex) {
         
        if (lowerIndex < higherIndex) {
            int middle = lowerIndex + (higherIndex - lowerIndex) / 2;
            // Below step sorts the left side of the array
            doMergeSort(lowerIndex, middle);
            // Below step sorts the right side of the array
            doMergeSort(middle + 1, higherIndex);
            // Now merge both sides
            mergeParts(lowerIndex, middle, higherIndex);
        }
    }
 
    private void mergeParts(int lowerIndex, int middle, int higherIndex) {
 
        for (int i = lowerIndex; i <= higherIndex; i++) {
            tempMergArr[i] = array[i];
        }
        int i = lowerIndex;
        int j = middle + 1;
        int k = lowerIndex;
        while (i <= middle && j <= higherIndex) {
            if (tempMergArr[i] <= tempMergArr[j]) {
                array[k] = tempMergArr[i];
                i++;
            } else {
                array[k] = tempMergArr[j];
                j++;
            }
            k++;
        }
        while (i <= middle) {
            array[k] = tempMergArr[i];
            k++;
            i++;
        }
 
    }
}
		</code>
    </article>
  </section>
  
  <section class="main-section" id="QuickSort">
    <header>Quick Sort</header>
    <article>
	   <p>It first divides a large list into two smaller sub-lists: the low elements and the high elements. Quicksort can then recursively sort the sub-lists.</p>   
	   <p>Code example:</p>
		<code>
public class QuickSort 
{
     
    private int array[];
    private int length;
 
    public void sort(int[] inputArr) {
         
        if (inputArr == null || inputArr.length == 0) {
            return;
        }
        this.array = inputArr;
        length = inputArr.length;
        quickSort(0, length - 1);
    }
 
    private void quickSort(int lowerIndex, int higherIndex) {
         
        int i = lowerIndex;
        int j = higherIndex;
        // calculate pivot number, I am taking pivot as middle index number
        int pivot = array[lowerIndex+(higherIndex-lowerIndex)/2];
        // Divide into two arrays
        while (i <= j) {
            /**
             * In each iteration, we will identify a number from left side which 
             * is greater then the pivot value, and also we will identify a number 
             * from right side which is less then the pivot value. Once the search 
             * is done, then we exchange both numbers.
             */
            while (array[i] < pivot) {
                i++;
            }
            while (array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                exchangeNumbers(i, j);
                //move index to next position on both sides
                i++;
                j--;
            }
        }
        // call quickSort() method recursively
        if (lowerIndex < j)
            quickSort(lowerIndex, j);
        if (i < higherIndex)
            quickSort(i, higherIndex);
    }
 
    private void exchangeNumbers(int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
     
    public static void main(String a[]){
         
        QuickSort sorter = new QuickSort();
        int[] input = {24,2,45,20,56,75,2,56,99,53,12};
        sorter.sort(input);
        for(int i:input){
            System.out.print(i);
            System.out.print(" ");
        }
    }
}
		</code>
    </article>
  </section>
 
<section class="main-section" id="SelectionSort">
    <header>Selection Sort</header>
    <article>
	   <p>Selects the smallest unsorted item and then swapping it with the item in the next position to be filled.</p>   
	   <p>Code example:</p>
		<code>
public class SelectionSort 
{
 
    public static int[] doSelectionSort(int[] arr){
         
        for (int i = 0; i < arr.length - 1; i++)
        {
            int index = i;
            for (int j = i + 1; j < arr.length; j++)
                if (arr[j] < arr[index]) 
                    index = j;
      
            int smallerNumber = arr[index];  
            arr[index] = arr[i];
            arr[i] = smallerNumber;
        }
        return arr;
    }
     
    public static void main(String a[]){
         
        int[] arr1 = {10,34,2,56,7,67,88,42};
        int[] arr2 = doSelectionSort(arr1);
        for(int i:arr2){
            System.out.print(i);
            System.out.print(", ");
        }
    }
}
		</code>
    </article>
  </section>
 
  
  <section class="main-section" id="Reference">
    <header>References</header>
    <article id="Reflinks">
	  <li> <a href="https://dev.to/pieohpah/what-each-sorting-algorithm-is-good-for-d65" target="_blank">What each sorting algorithm is good for</a> </li>
	  <li> <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting Algorithms/sorting.html" target="_blank">Sorting</a> </li>
      <li> <a href="http://www.java2novice.com/java-sorting-algorithms/" target="_blank">Java Sorting Algorithms</a> </li>  
    </article>
  </section>
	
</main>


</body>

</html>
